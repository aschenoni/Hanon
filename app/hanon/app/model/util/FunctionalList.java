package hanon.app.model.util;

import hanon.app.model.music.StaffElement;

import java.util.ArrayList;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;

public class FunctionalList<A> {
  private final A head;
  private final FunctionalList<A> tail;

  /**
   * Add the context of non-determinism to an item.
   *
   * pure(5) -> [5]
   */
  public static <A> FunctionalList<A> pure(A head) {
    return FunctionalList.<A>empty().prepend(head);
  }

  /**
   * empty() -> []
   */
  public static <A> FunctionalList<A> empty() {
    return new FunctionalList<A>(null, null);
  }

  public static <A> FunctionalList<A> fromIterable(Iterable<A> list) {
    FunctionalList<A> fl = FunctionalList.<A>empty();
    for(A a : list) fl = fl.prepend(a);
    return fl.reverse();
  }

  public static <A> FunctionalList<A> fromArray(A[] array) {
    FunctionalList<A> fl = FunctionalList.<A>empty();
    for(A a : array) fl = fl.prepend(a);
    return fl.reverse();
  }

  /**
   * A functional list should only be constructed by a user using one of the
   * static constructor methods provided.
   */
  private FunctionalList(A head, FunctionalList<A> tail) {
    this.head = head;
    this.tail = tail;
  }

  public List<A> toArrayList() {
    return foldr(((A elem, List<A> list) ->
            addToArrayList(list, elem)), new ArrayList<A>());
  }
  private List<A> addToArrayList(List<A> list, A elem) {
    list.add(0, elem);
    return list;
  }

  /**
   * Get the first item in the list.
   *
   * [1,2,3] -> 1
   */
  public A head() {
    return head;
  }

  /**
   * Get the list remaining without the first item in the list.
   *
   * [1,2,3] -> [2,3]
   */
  public FunctionalList<A> tail() {
    return tail;
  }

  /**
   * Get the last element in the list.
   *
   * [1,2,3] -> [3]
   */
  public A last() {
    if (tail.isEmpty()) return head;
    else return tail.last();
  }

  public boolean isEmpty() {
    return tail == null;
  }

  public int size() {
    if (isEmpty()) return 0;
    else return 1 + tail.size();
  }

  /**
   * Get a new list with an item added at the front.
   *
   * [2,3].prepend(1) -> [1,2,3]
   */
  public FunctionalList<A> prepend(A data) {
    return new FunctionalList<>(data, this);
  }

  /**
   * Get a new list with the other list added at the end.
   *
   * [1,2,3].append(4,5,6) -> [1,2,3,4,5,6]
   */
  public FunctionalList<A> append(FunctionalList<A> other) {
    if (isEmpty()) return other;
    else return new FunctionalList<>(head, tail.append(other));
  }

  /**
   * Get a new list with the contents of the original list reversed.
   *
   * [1,2,3].reverse() -> [3,2,1]
   */
  public FunctionalList<A> reverse() {
    if (isEmpty()) return empty();
    else return tail.reverse().append(FunctionalList.<A>empty().prepend(head));
  }

  /**
   * Get a new list generated by applying the given function to every item of
   * the original list. The function should only take one parameter which
   * should be the type of the content of the original list.
   *
   * [4.0, 9.0, 16.0].map(Math::sqrt) -> [2.0, 3.0, 4.0]
   */
  public <B> FunctionalList<B> map(Function<A, B> f) {
    if (isEmpty()) return FunctionalList.<B>empty();
    else return tail().map(f).prepend(f.apply(head()));
  }

  /**
   * Reduce the original list to a single result.
   */
  public <B> B foldr(BiFunction<A, B, B> f, B acc) {
    if (isEmpty()) return acc;
    else return f.apply(head, tail.foldr(f, acc));
  }

  public <B> B foldl(BiFunction<B, A, B> f, B acc) {
    if (isEmpty()) return acc;
    else return tail.foldl(f, f.apply(acc, head));
  }

  public A foldl1(BiFunction<A, A, A> f) {
    return foldl(f, head);
  }


  public FunctionalList<A> filter(Predicate<A> p) {
    if (isEmpty()) return empty();
    else {
      if (p.test(head)) return tail.filter(p).prepend(head);
      else              return tail.filter(p);
    }
  }

  public FunctionalList<A> takeWhile(Predicate<A> p) {
    if (isEmpty()) return empty();
    else
      if (p.test(head)) return tail.takeWhile(p).prepend(head);
      else return empty();
  }

  public FunctionalList<A> drop(int num) {
    if (isEmpty()) return empty();
    else if (num <= 0) return this;
    else return tail.drop(num-1);
  }

  /**
   * Get the list of all initial segments of the list.
   *
   * [3, 4, 5] -> [[], [3], [3, 4], [3, 4, 5]]
   */
  public FunctionalList<FunctionalList<A>> inits() {
    if (isEmpty()) return emptyListOfLists().prepend(empty());
    else return tail.inits().map((FunctionalList<A> list) ->
            list.prepend(head)).prepend(empty());
  }

  public FunctionalList<FunctionalList<A>> tails() {
    if (isEmpty()) return emptyListOfLists().prepend(this);
    else return tail.tails().prepend(this);
  }

  private FunctionalList<FunctionalList<A>> emptyListOfLists() {
    return FunctionalList.<FunctionalList<A>>empty();
  }

  public <B, C> FunctionalList<C> zipWith(BiFunction<A, B, C> f, FunctionalList<B> other) {
    if (isEmpty()) return empty();
    else if (other.isEmpty()) return empty();
    else return tail.zipWith(f, other.tail).prepend(f.apply(head, other.head()));
  }

  /**
   * Non-deterministically apply a function to the list.
   *
   * [4,5,6].bind(MtMath::primeFactors) -> [2, 5, 2, 3]
   */
  public <B> FunctionalList<B> bind(Function<A, FunctionalList<B>> f) {
    return concat(map(f));
  }
  /**
   * Flatten a list of lists into one list.
   *
   * concat([[1, 2], [3, 4]]) -> [1, 2, 3, 4]
   */
  public static <A> FunctionalList<A> concat(FunctionalList<FunctionalList<A>> list) {
    return list.foldr((FunctionalList<A>::append), FunctionalList.<A>empty());
  }

  public static Comparable minimum(FunctionalList<Comparable> list) {
    return list.foldl1((a1, a2) -> a1.compareTo(a2) > 0 ? a2 : a1);
  }

  public static Comparable maximum(FunctionalList<Comparable> list) {
    return list.foldl1((a1, a2) -> a1.compareTo(a2) < 0 ? a2 : a1);
  }

  @Override
  public boolean equals(Object o) {
    if (!(o instanceof FunctionalList)) return false;
    else {
      FunctionalList<A> fl = (FunctionalList<A>)o;
      return isEmpty() && fl.isEmpty() ||
             head().equals(fl.head()) && tail().equals(fl.tail());
    }
  }
  @Override
  public int hashCode() {
    if (isEmpty()) return 1337;
    else return 13 * (head.hashCode() + 31*tail.hashCode());
  }

  @Override
  public String toString() {
    return "[" + toStringHelper();
  }

  private String toStringHelper() {
    if (isEmpty()) return "]";
    else if (tail.isEmpty()) return head().toString() + tail.toStringHelper();
    else return head().toString() + ", " + tail.toStringHelper();
  }
}